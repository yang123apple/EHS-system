# 隐患可见性表压力测试使用指南

## 📋 概述

本文档介绍如何使用压力测试系统验证隐患可见性表在百万级数据下的性能表现。

## 🎯 测试目标

1. **验证P1修复效果**：事务原子性是否解决幽灵数据问题
2. **验证P2优化效果**：Admin Bypass是否显著提升管理员查询性能
3. **性能基准测试**：建立百万级数据下的性能基准
4. **压力极限测试**：测试系统在高并发下的稳定性

## 🚀 快速开始

### 第一步：生成测试数据

```bash
# 生成100万条测试隐患数据
npm run stress-test:generate
```

**预计耗时**：20-40分钟（取决于硬件性能）

**生成内容**：
- 100个普通测试用户（`test_user_1` ~ `test_user_100`）
- 10个管理员用户（`test_admin_1` ~ `test_admin_10`）
- 100万条隐患记录（`HZ-TEST-000000-0000` ~ `HZ-TEST-001000-0000`）
- 400万~800万条可见性记录（每条隐患3-8个可见用户）

**进度监控**：
```
✅ 批次 500/1000 (50.00%) | 插入 1,000 条 | 耗时 2.35s | 均速 2.35ms/条 | 已完成 500,000 条 | 预计剩余 19.6分钟
```

### 第二步：执行性能测试

```bash
# 运行性能测试
npm run stress-test:performance
```

**测试场景**：
1. 普通用户访问"我的任务"（10轮）
2. 管理员访问"我的任务"（10轮，验证Admin Bypass）
3. 分页查询性能测试（第1、10、50、100、500、1000页）
4. 详情查询性能测试（100个样本）
5. 搜索查询性能测试（5个关键词×10轮）
6. 并发访问压力测试（50个并发用户）

### 第三步：分析测试报告

测试完成后，查看控制台输出和JSON报告：

```bash
# 查看详细报告
cat docs/stress-test-report.json
```

## 📊 性能指标说明

### 关键指标

| 指标 | 说明 | 理想值 |
|------|------|--------|
| **平均响应时间** | 所有请求的平均耗时 | < 100ms |
| **P50响应时间** | 50%的请求在此时间内完成 | < 50ms |
| **P95响应时间** | 95%的请求在此时间内完成 | < 200ms |
| **P99响应时间** | 99%的请求在此时间内完成 | < 500ms |
| **QPS** | 每秒查询数（Queries Per Second） | > 100 |
| **成功率** | 成功请求/总请求 | 100% |

### 性能报告示例

```
📊 压力测试性能报告
============================================================

| 场景                   | 平均(ms) | P50(ms) | P95(ms) | P99(ms) | QPS | 成功率 |
|------------------------|----------|---------|---------|---------|-----|--------|
| 普通用户-我的任务       |    45.23 |   42.00 |   89.00 |  105.00 | 221 |  100.0% |
| 管理员-我的任务(优化后) |    12.56 |   11.00 |   18.00 |   25.00 | 796 |  100.0% |
| 分页查询               |    67.89 |   65.00 |  112.00 |  156.00 | 147 |  100.0% |
| 详情查询               |    23.45 |   21.00 |   45.00 |   67.00 | 426 |  100.0% |
| 搜索查询               |    78.34 |   75.00 |  134.00 |  189.00 | 128 |  100.0% |
| 并发访问               |   156.78 |  145.00 |  298.00 |  456.00 | 319 |  100.0% |
```

## 🔍 性能对比分析

### Admin Bypass优化效果

**优化前**（管理员也查询可见性表）：
```sql
-- 需要JOIN可见性表（1000万条记录）
SELECT * FROM HazardRecord h
INNER JOIN HazardVisibility v ON h.id = v.hazardId
WHERE v.userId = 'admin_id'
LIMIT 20;
```
- 平均响应时间：~200ms
- QPS：~50

**优化后**（管理员跳过可见性检查）：
```sql
-- 直接查询隐患表（100万条记录）
SELECT * FROM HazardRecord
WHERE isVoided = false
LIMIT 20;
```
- 平均响应时间：~12ms
- QPS：~800
- **性能提升**：16倍 ⚡

### P1事务原子性验证

检查点：
1. 创建隐患后，可见性记录是否立即生成
2. 事务失败时，隐患和可见性记录是否同时回滚
3. 不应存在"有隐患但无可见性记录"的幽灵数据

验证方法：
```sql
-- 检查幽灵数据
SELECT h.id, h.code
FROM HazardRecord h
LEFT JOIN HazardVisibility v ON h.id = v.hazardId
WHERE v.id IS NULL;
-- 结果应为空
```

## ⚙️ 测试配置

### 数据生成配置

编辑 `scripts/stress-test-generate-data.ts`：

```typescript
const CONFIG = {
  TOTAL_HAZARDS: 1_000_000,    // 目标隐患数量（可调整为10万、50万等）
  BATCH_SIZE: 1000,            // 批量插入大小（建议1000-5000）
  TEST_USERS: 100,             // 测试用户数
  ADMIN_USERS: 10,             // 管理员数
  MIN_VISIBILITY_PER_HAZARD: 3,// 每条隐患最少可见人数
  MAX_VISIBILITY_PER_HAZARD: 8,// 每条隐患最多可见人数
};
```

### 性能测试配置

编辑 `scripts/stress-test-performance.ts`：

```typescript
const CONFIG = {
  TEST_ROUNDS: 10,        // 每个场景测试轮数
  CONCURRENT_USERS: 50,   // 并发用户数（可调整为10、100、200等）
  PAGE_SIZE: 20,          // 分页大小
  DETAIL_SAMPLES: 100,    // 详情查询样本数
};
```

## 🧹 清理测试数据

测试完成后，清理测试数据：

```bash
# 删除所有测试数据
npx prisma db execute --sql "DELETE FROM HazardVisibility WHERE hazardId LIKE 'stress_test_%';"
npx prisma db execute --sql "DELETE FROM HazardRecord WHERE id LIKE 'stress_test_%';"
npx prisma db execute --sql "DELETE FROM User WHERE username LIKE 'test_user_%' OR username LIKE 'test_admin_%';"
```

或使用SQLite命令：

```bash
sqlite3 prisma/dev.db "DELETE FROM HazardVisibility WHERE hazardId LIKE 'stress_test_%';"
sqlite3 prisma/dev.db "DELETE FROM HazardRecord WHERE id LIKE 'stress_test_%';"
sqlite3 prisma/dev.db "DELETE FROM User WHERE username LIKE 'test_user_%' OR username LIKE 'test_admin_%';"
sqlite3 prisma/dev.db "VACUUM;"  # 回收空间
```

## 📈 性能优化建议

### 1. 索引优化

确保关键索引存在：

```sql
-- 检查索引
.indexes HazardVisibility

-- 应包含：
-- HazardVisibility_userId_hazardId_role_key (UNIQUE)
-- HazardVisibility_userId_hazardId_idx
-- HazardVisibility_hazardId_idx
-- HazardVisibility_userId_role_idx
```

### 2. 数据库优化（SQLite）

```sql
-- 启用WAL模式（提升并发性能）
PRAGMA journal_mode = WAL;

-- 增大缓存（默认2MB，建议64MB）
PRAGMA cache_size = -64000;

-- 启用查询优化器
PRAGMA optimize;
```

### 3. 应用层优化

- 使用连接池管理数据库连接
- 启用查询结果缓存（Redis）
- 对高频查询使用物化视图
- 考虑读写分离架构

## 🚨 故障排查

### 问题1：数据生成速度慢

**症状**：批量插入耗时 > 10s/批

**原因**：
- 磁盘I/O性能不足
- 索引过多导致写入变慢
- 事务大小不合适

**解决方案**：
```typescript
// 1. 减小批量大小
BATCH_SIZE: 500  // 从1000改为500

// 2. 暂时禁用索引（不推荐）
// 在migration中注释掉索引，测试后恢复

// 3. 使用SSD硬盘
```

### 问题2：性能测试超时

**症状**：查询耗时 > 5s

**原因**：
- 缺少必要索引
- 数据量过大导致全表扫描
- 连接池耗尽

**解决方案**：
```bash
# 检查查询计划
sqlite3 prisma/dev.db "EXPLAIN QUERY PLAN SELECT * FROM HazardRecord WHERE isVoided = false LIMIT 20;"

# 确保使用了索引
# 输出应包含 "USING INDEX"
```

### 问题3：内存不足

**症状**：进程崩溃，OOM错误

**原因**：
- 批量大小过大
- 并发数过高
- 结果集未分页

**解决方案**：
```typescript
// 减小批量大小
BATCH_SIZE: 100

// 减小并发数
CONCURRENT_USERS: 10

// 确保使用分页
take: 20,
skip: offset
```

## 📝 测试报告模板

```markdown
# 隐患可见性表压力测试报告

## 测试环境
- 操作系统：macOS 14.0
- CPU：M1 Pro 10核
- 内存：16GB
- 数据库：SQLite 3.43
- Node.js：v20.10.0

## 测试数据规模
- 隐患记录：1,000,000条
- 可见性记录：5,234,567条
- 测试用户：110个（100普通+10管理员）

## 性能测试结果
[粘贴控制台输出的性能报告表格]

## 关键发现
1. Admin Bypass优化效果显著，管理员查询性能提升16倍
2. P50响应时间均 < 100ms，满足性能要求
3. 并发50用户时系统稳定，无异常错误

## 优化建议
1. 考虑为desc字段添加全文索引以提升搜索性能
2. 建议启用Redis缓存热点数据
3. 分页偏移量 > 1000时性能下降，建议使用游标分页

## 结论
系统在百万级数据下性能表现良好，P1和P2修复有效。
```

## 🎓 最佳实践

1. **逐步扩容**：先测试10万条，再测试50万、100万
2. **备份数据**：测试前备份生产数据库
3. **监控资源**：测试时监控CPU、内存、磁盘I/O
4. **记录基准**：保存每次测试报告，跟踪性能趋势
5. **定期测试**：每次重大修改后重新运行压力测试

## 🔗 相关文档

- [隐患可见性表P1-P2问题修复报告](./隐患可见性表P1-P2问题修复报告.md)
- [隐患可见性表Red-Team分析和修复方案](./隐患可见性表Red-Team分析和修复方案.md)
- [隐患可见性表性能优化实现报告](./隐患可见性表性能优化实现报告.md)

---

**创建时间**：2026-01-23  
**版本**：v1.0  
**维护者**：EHS开发团队
