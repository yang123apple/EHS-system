# EHS 作业管理系统架构重构说明

## 概述

本次重构主要解决以下问题：
1. **数据孤岛与报表统计问题**：通过数据映射层，使关键字段可用于 SQL 统计查询
2. **电子签名法律效力**：实现符合审计要求的电子签名方案，包含防篡改机制
3. **子表单架构解耦**：将二级表单数据从父表单 JSON 中分离，存储到独立表
4. **离线支持**：提供基于 IndexedDB 的暂存和同步机制

---

## 1. 数据映射层 (Data Mapping Layer)

### 1.1 设计目标

解决所有业务数据都在 `dataJson` 中，无法使用 SQL 进行统计查询的问题。

### 1.2 实现方案

在 `WorkPermitRecord` 表中新增关键索引列：
- `riskLevel`: 风险等级
- `workType`: 作业类型
- `location`: 作业地点
- `applicantId`: 申请人ID
- `applicantName`: 申请人姓名
- `applicantDept`: 申请人部门
- `workDate`: 作业日期
- `workStartTime`: 作业开始时间
- `workEndTime`: 作业结束时间
- `supervisorId`: 监护人ID
- `supervisorName`: 监护人姓名

### 1.3 使用方式

**工具函数**: `src/utils/dataMapper.ts`

```typescript
import { mapJsonToColumns } from '@/utils/dataMapper';

// 在创建/更新作业票时自动提取关键字段
const mappedFields = mapJsonToColumns(dataJson, parsedFields);

// 保存到数据库时，同时保存 dataJson 和映射字段
await prisma.workPermitRecord.create({
  data: {
    dataJson: JSON.stringify(dataJson),
    ...mappedFields, // 自动填充关键字段
  }
});
```

### 1.4 统计查询示例

现在可以使用 SQL 进行统计查询：

```typescript
// 统计某部门本月动火作业次数
const count = await prisma.workPermitRecord.count({
  where: {
    applicantDept: '生产部',
    workType: '动火作业',
    workDate: {
      gte: new Date(2024, 0, 1), // 本月开始
      lte: new Date(2024, 0, 31), // 本月结束
    },
  },
});

// 按风险等级分组统计
const stats = await prisma.workPermitRecord.groupBy({
  by: ['riskLevel'],
  _count: true,
  where: {
    workDate: {
      gte: new Date(2024, 0, 1),
    },
  },
});
```

---

## 2. 电子签名法律效力 (Legal Validity of E-Signatures)

### 2.1 设计目标

实现符合审计要求的电子签名方案，确保签字后内容未被篡改。

### 2.2 实现方案

**新增表**: `SignatureRecord`

核心字段：
- `dataSnapshotHash`: 签字时刻表单数据的 Hash 值（SHA-256）
- `dataSnapshot`: 签字时刻表单数据的完整快照（可选，用于审计）
- `signerId`, `signerName`: 签字人信息
- `action`: 操作类型（pass/reject/issue/site_confirm）
- `stepIndex`, `stepName`: 审批步骤信息
- `clientInfo`: 客户端环境信息（用于审计）

### 2.3 使用方式

**服务函数**: `src/services/signatureService.ts`

```typescript
import { createSignature, verifySignature } from '@/services/signatureService';

// 在审批时创建签名记录
await createSignature(
  {
    permitId: recordId,
    signerId: userId,
    signerName: userName,
    action: 'pass',
    comment: opinion,
    stepIndex: currentStepIndex,
    stepName: currentStepConfig?.name,
    clientInfo: extractClientInfo(req),
  },
  dataJson, // 签字时刻的数据快照
  false // 不保存完整快照，仅保存 Hash
);

// 验证数据是否被篡改
const result = await verifySignature(permitId, currentDataJson);
if (!result.isValid) {
  console.error('数据已被篡改:', result.reason);
}
```

### 2.4 防篡改机制

1. **签字时刻**：计算表单数据的 SHA-256 Hash 值并存储
2. **验证时刻**：重新计算当前数据的 Hash 值，与存储的 Hash 值对比
3. **审计追溯**：记录签字人、时间、客户端环境等完整信息

---

## 3. 子表单架构解耦 (Decoupling Sub-forms)

### 3.1 设计目标

将二级表单数据从父表单 JSON 中分离，解决：
- 父表单 JSON 过大问题
- 并发写入冲突问题
- 子表单数据难以独立管理的问题

### 3.2 实现方案

**新增表**: `SubPermit`

核心字段：
- `parentPermitId`: 父表单ID
- `templateId`: 绑定的二级模板ID
- `cellKey`: 父表单中绑定的单元格键（如：R5C3）
- `dataJson`: 子表单的完整数据
- `code`: 子表单编号

**数据存储策略**：
- 父表单 JSON 中只保留子表单的 ID 引用：`{ _subPermitId: "xxx" }`
- 子表单的实际数据存储在 `SubPermit` 表中

### 3.3 数据读写流程

#### 3.3.1 创建子表单

```typescript
import { createSubPermit } from '@/services/subPermitService';

// 1. 创建子表单记录
const subPermit = await createSubPermit({
  parentPermitId: 'parent-id',
  templateId: 'template-id',
  cellKey: 'R5C3',
  fieldName: '每日施工单',
  dataJson: subFormData,
});

// 2. 自动更新父表单 JSON：将子表单数据替换为 ID 引用
// 父表单 JSON 中的 R5C3 单元格变为：
// { _subPermitId: "sub-permit-id", _display: "[子表单:sub-permit-id]" }
```

#### 3.3.2 读取子表单

```typescript
import { getSubPermitByCellKey } from '@/services/subPermitService';

// 从父表单 JSON 中提取子表单 ID
const parentData = JSON.parse(parentPermit.dataJson);
const subPermitId = parentData['R5C3']?._subPermitId;

if (subPermitId) {
  // 查询子表单数据
  const subPermit = await getSubPermit(subPermitId);
  const subFormData = JSON.parse(subPermit.dataJson);
}
```

#### 3.3.3 更新子表单

```typescript
import { updateSubPermit } from '@/services/subPermitService';

// 直接更新子表单，不影响父表单
await updateSubPermit(subPermitId, {
  dataJson: updatedSubFormData,
  status: 'approved',
});
```

#### 3.3.4 删除子表单

```typescript
import { deleteSubPermit } from '@/services/subPermitService';

// 删除子表单，并自动从父表单 JSON 中移除引用
await deleteSubPermit(subPermitId);
```

### 3.4 数据迁移

对于现有的嵌套子表单数据，可以使用迁移工具：

```typescript
import { extractSubPermitsFromParent } from '@/services/subPermitService';

// 从父表单 JSON 中提取所有子表单数据，创建独立的 SubPermit 记录
const extracted = await extractSubPermitsFromParent(parentPermitId);
```

### 3.5 API 端点

- `GET /api/sub-permits?id=xxx` - 获取单个子表单
- `GET /api/sub-permits?parentPermitId=xxx` - 获取父表单的所有子表单
- `GET /api/sub-permits?parentPermitId=xxx&cellKey=R5C3` - 根据单元格键获取
- `POST /api/sub-permits` - 创建子表单
- `PATCH /api/sub-permits` - 更新子表单
- `DELETE /api/sub-permits?id=xxx` - 删除子表单
- `PUT /api/sub-permits` - 从父表单提取子表单（迁移工具）

---

## 4. 离线支持 (Offline Capabilities)

### 4.1 设计目标

在工厂车间信号差的情况下，允许用户在断网时暂存表单数据，网络恢复时自动同步。

### 4.2 实现方案

**基于 IndexedDB 的离线存储**

- 使用 IndexedDB 存储待同步的数据
- 监听网络状态变化
- 网络恢复时自动同步

### 4.3 使用方式

**Hook**: `src/hooks/useOfflineStorage.ts`

```typescript
import { useOfflineStorage } from '@/hooks/useOfflineStorage';

function MyComponent() {
  const { isOnline, pendingCount, saveOffline, syncPendingItems } = useOfflineStorage();
  
  // 保存到离线存储
  const handleSave = async () => {
    try {
      await fetch('/api/permits', { ... });
    } catch (error) {
      // 网络错误，保存到离线存储
      if (!navigator.onLine) {
        await saveOffline('permit', formData);
      }
    }
  };
  
  // 显示离线状态
  return (
    <div>
      {!isOnline && <div>离线模式，已保存 {pendingCount} 条待同步数据</div>}
      {pendingCount > 0 && (
        <button onClick={syncPendingItems}>手动同步</button>
      )}
    </div>
  );
}
```

### 4.4 自动同步机制

1. **网络恢复检测**：监听 `online` 事件
2. **自动同步**：网络恢复时自动同步所有待同步项
3. **重试机制**：同步失败时增加重试次数，超过5次后跳过
4. **状态管理**：跟踪同步状态，避免重复同步

---

## 5. 数据库迁移

### 5.1 生成迁移文件

```bash
npx prisma migrate dev --name add_data_mapping_and_signatures
```

### 5.2 迁移步骤

1. **更新 Schema**：已更新 `prisma/schema.prisma`
2. **生成迁移**：运行上述命令
3. **数据迁移**（可选）：
   - 对于现有数据，可以运行数据映射函数提取关键字段
   - 对于嵌套子表单，可以使用 `extractSubPermitsFromParent` 迁移

---

## 6. 性能优化建议

### 6.1 索引优化

已为关键字段添加索引：
- 单列索引：`riskLevel`, `workType`, `location`, `applicantDept`, `workDate`
- 复合索引：`[workType, workDate]`, `[applicantDept, workDate]`

### 6.2 查询优化

- 统计查询优先使用映射字段，避免全表扫描 `dataJson`
- 子表单查询使用独立表，避免解析大型 JSON

### 6.3 存储优化

- 电子签名默认不保存完整快照，仅保存 Hash（节省存储空间）
- 子表单数据独立存储，减少父表单 JSON 大小

---

## 7. 兼容性说明

### 7.1 向后兼容

- `dataJson` 字段仍然保留，现有功能不受影响
- 映射字段为可选字段（`String?`），现有数据可以逐步迁移

### 7.2 渐进式迁移

1. **第一阶段**：新数据自动提取映射字段
2. **第二阶段**：对现有数据运行迁移脚本
3. **第三阶段**：逐步将子表单数据迁移到独立表

---

## 8. 测试建议

### 8.1 单元测试

- 数据映射函数：测试各种 JSON 格式的解析
- 电子签名服务：测试 Hash 计算和验证逻辑
- 子表单服务：测试 CRUD 操作和父表单 JSON 更新

### 8.2 集成测试

- API 路由：测试创建/更新作业票时的数据映射
- 审批流程：测试电子签名的创建和验证
- 子表单流程：测试子表单的创建、读取、更新、删除

### 8.3 性能测试

- 统计查询性能对比（使用映射字段 vs 解析 JSON）
- 大型 JSON 的处理性能
- 离线存储的读写性能

---

## 9. 后续优化方向

1. **数据映射配置化**：允许通过配置定义字段映射规则
2. **签名可视化**：在前端展示签名记录和验证状态
3. **离线冲突解决**：处理离线编辑冲突的场景
4. **批量迁移工具**：提供 CLI 工具批量迁移现有数据

---

## 10. 总结

本次架构重构实现了：

✅ **数据映射层**：解决数据孤岛问题，支持 SQL 统计查询  
✅ **电子签名**：符合审计要求，包含防篡改机制  
✅ **子表单解耦**：独立存储，解决并发和性能问题  
✅ **离线支持**：基于 IndexedDB 的暂存和同步机制  

所有功能均已实现并集成到现有系统中，保持向后兼容，支持渐进式迁移。

