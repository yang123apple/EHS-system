# 场景2：孤儿隐患自动驳回修复说明

**修复日期**: 2026-01-24  
**问题**: 当隐患当前执行人的用户账户被删除或进入离职状态时，隐患成为"孤儿"，无法被正常处理。

---

## 修复方案

### 核心逻辑

当用户被删除或状态更新为离职时，系统会自动：
1. **查找所有以该用户为执行人且未闭环的隐患**
2. **自动驳回这些隐患**（使用派发引擎的 REJECT 动作）
3. **通知发起人**："隐患当前执行人账号不存在，请重新发起"
4. **清空执行人字段**，将隐患状态回退到"上报"步骤

---

## 代码修改

### 1. 新增服务：`src/services/hazardAutoReject.service.ts`

**功能**：
- `autoRejectHazardsByExecutor()`: 检查并自动驳回执行人已离职/删除的隐患
- `rejectHazardForDeletedExecutor()`: 驳回单条隐患的内部函数

**关键逻辑**：
```typescript
// 1. 查询所有以该用户为当前执行人且未闭环的隐患
const hazards = await prisma.hazardRecord.findMany({
  where: {
    dopersonal_ID: userId,
    deletedAt: null,
    status: { not: 'closed' }
  }
});

// 2. 使用派发引擎执行驳回操作
const dispatchResult = await HazardDispatchEngine.dispatch({
  hazard,
  action: DispatchAction.REJECT,
  operator: { id: 'system', name: '系统' },
  // ...
});

// 3. 更新隐患记录，清空执行人
await tx.hazardRecord.update({
  where: { id: hazard.id },
  data: {
    status: dispatchResult.newStatus,
    dopersonal_ID: null,
    dopersonal_Name: null,
    // ...
  }
});

// 4. 通知发起人
if (hazard.reporterId && hazard.reporterId !== 'DELETED_USER') {
  // 创建通知
  await tx.notification.createMany({
    data: [{
      userId: hazard.reporterId,
      type: 'hazard_rejected',
      title: '隐患已自动驳回',
      content: `隐患"${hazard.code}"的当前执行人账号不存在，已自动驳回，请重新发起。`,
      // ...
    }]
  });
}
```

---

### 2. 修改用户删除逻辑：`src/lib/db.ts`

**位置**: `deleteUser()` 函数

**修改内容**：
```typescript
deleteUser: async (id: string) => {
  // 🆕 步骤0: 在删除用户前，自动驳回该用户作为执行人的隐患
  try {
    const { autoRejectHazardsByExecutor } = await import('@/services/hazardAutoReject.service');
    const rejectResult = await autoRejectHazardsByExecutor(
      id,
      '执行人账户已删除'
    );
    console.log(`[用户删除] 自动驳回隐患结果: 成功 ${rejectResult.rejectedCount} 条`);
  } catch (rejectError) {
    console.error('[用户删除] 自动驳回隐患失败（不影响用户删除）:', rejectError);
    // 不阻断用户删除流程，只记录错误
  }

  // 继续原有的用户删除逻辑...
  await prisma.$transaction(async (tx) => {
    // ... 原有逻辑
    
    // 🆕 清除该用户作为当前执行人的隐患记录
    await tx.hazardRecord.updateMany({
      where: { dopersonal_ID: id },
      data: { dopersonal_ID: null, dopersonal_Name: null }
    });

    // 🆕 清除该用户作为验收人的隐患记录
    await tx.hazardRecord.updateMany({
      where: { verifierId: id },
      data: { verifierId: null, verifierName: null }
    });

    // 🆕 清理可见性表中的该用户记录
    await tx.hazardVisibility.deleteMany({
      where: { userId: id }
    });
  });
}
```

---

### 3. 修改用户更新逻辑：`src/app/api/users/[id]/route.ts`

**位置**: `PUT` 方法

**修改内容**：
```typescript
// 🆕 检查用户是否从在职变为离职（isActive: true -> false）
const wasActive = existingUser.isActive !== false; // 默认为 true
const willBeActive = updateData.isActive !== false; // 如果未提供，默认为 true

// 更新用户
const updatedUser = await db.updateUser(id, updateData);

// 🆕 如果用户从在职变为离职，自动驳回该用户作为执行人的隐患
if (wasActive && !willBeActive) {
  try {
    const { autoRejectHazardsByExecutor } = await import('@/services/hazardAutoReject.service');
    const rejectResult = await autoRejectHazardsByExecutor(
      id,
      '执行人已离职'
    );
    console.log(`[用户更新] 用户 ${id} 离职，自动驳回隐患结果: 成功 ${rejectResult.rejectedCount} 条`);
  } catch (rejectError) {
    console.error('[用户更新] 自动驳回隐患失败（不影响用户更新）:', rejectError);
  }
}
```

---

## 工作流程

### 场景A：用户删除

```
1. 管理员删除用户 User A
   ↓
2. 系统调用 autoRejectHazardsByExecutor(User A, '执行人账户已删除')
   ↓
3. 查询所有以 User A 为执行人的未闭环隐患
   ↓
4. 对每条隐患：
   a. 使用派发引擎执行 REJECT 动作
   b. 隐患状态回退到"上报"步骤
   c. 清空 dopersonal_ID 和 dopersonal_Name
   d. 记录系统日志
   e. 同步可见性表
   f. 通知发起人（如果存在且未删除）
   ↓
5. 继续执行用户删除流程
   - 清理隐患关联字段
   - 清理可见性表记录
   - 删除用户记录
```

### 场景B：用户离职

```
1. 管理员将用户 User A 的 isActive 设置为 false
   ↓
2. 系统检测到 isActive 从 true 变为 false
   ↓
3. 系统调用 autoRejectHazardsByExecutor(User A, '执行人已离职')
   ↓
4. 执行与场景A相同的自动驳回流程
   ↓
5. 继续执行用户更新流程
```

---

## 通知内容

**通知类型**: `hazard_rejected`

**标题**: `隐患已自动驳回`

**内容**: `隐患"[隐患编号]"（[位置]）的当前执行人账号不存在，已自动驳回，请重新发起。`

**接收人**: 隐患发起人（`reporterId`）

**条件**: 
- 发起人存在且未删除（`reporterId !== 'DELETED_USER'`）
- 发起人账户未被删除（`deletedAt === null`）

---

## 错误处理

1. **自动驳回失败不影响用户删除/更新**
   - 如果自动驳回过程中出现错误，只记录日志，不阻断主流程
   - 错误信息会记录在返回结果的 `errors` 数组中

2. **部分隐患驳回失败**
   - 如果某条隐患驳回失败，会记录错误但继续处理其他隐患
   - 最终返回成功和失败的统计信息

---

## 测试建议

### 测试场景1：用户删除
1. 创建一条隐患，指派给 User A
2. 删除 User A
3. 验证：
   - 隐患状态是否回退到"上报"
   - 执行人字段是否清空
   - 发起人是否收到通知
   - 可见性表是否正确更新

### 测试场景2：用户离职
1. 创建一条隐患，指派给 User A
2. 将 User A 的 `isActive` 设置为 `false`
3. 验证：同上

### 测试场景3：多条隐患
1. 创建多条隐患，都指派给 User A
2. 删除 User A
3. 验证：所有隐患都被正确驳回

### 测试场景4：发起人已删除
1. 创建隐患，指派给 User A，发起人为 User B
2. 删除 User B（发起人）
3. 删除 User A（执行人）
4. 验证：隐患被驳回，但不发送通知（因为发起人已删除）

---

## 注意事项

1. **工作流配置依赖**
   - 自动驳回需要读取工作流配置文件 `data/hazard-workflow.json`
   - 如果配置文件不存在，会使用默认配置

2. **事务处理**
   - 每条隐患的驳回操作都在独立事务中执行
   - 确保数据一致性，即使某条失败也不影响其他隐患

3. **性能考虑**
   - 如果用户有大量隐患，自动驳回可能需要一些时间
   - 建议在后台异步处理，或使用队列系统

4. **日志记录**
   - 所有操作都会记录系统日志
   - 日志包含操作人（系统）、操作时间、操作内容

---

## 相关文件

- `src/services/hazardAutoReject.service.ts` - 自动驳回服务
- `src/lib/db.ts` - 用户删除逻辑
- `src/app/api/users/[id]/route.ts` - 用户更新逻辑
- `src/services/hazardDispatchEngine.ts` - 派发引擎（用于驳回）
- `src/services/hazardNotification.service.ts` - 通知服务
- `src/services/hazardVisibility.service.ts` - 可见性同步服务

---

**修复完成** ✅
